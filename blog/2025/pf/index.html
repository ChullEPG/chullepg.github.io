<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Rolling 2D Sectors into 3D Cones (Vector Pushforward) | Chris Hull </title> <meta name="author" content="Chris Hull"> <meta name="description" content="Explore how to transform 2D vector fields into 3D space with a step-by-step derivation of the pushforward and pullback processes."> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" href="/assets/css/scholar-icons.css?62b2ac103a88034e6882a5be5f3e2772"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://chullepg.github.io/blog/2025/pf/"> <script src="/assets/js/theme.js?9a0c749ec5240d9cda97bc72359a72c0"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>
    initTheme();
  </script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Chris</span> Hull </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">publications </a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">projects </a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">repositories </a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv </a> </li> <li class="nav-item dropdown "> <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">submenus </a> <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown"> <a class="dropdown-item " href="/publications/">publications</a> <div class="dropdown-divider"></div> <a class="dropdown-item " href="/projects/">projects</a> <div class="dropdown-divider"></div> <a class="dropdown-item " href="/blog/">blog</a> </div> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">Rolling 2D Sectors into 3D Cones (Vector Pushforward)</h1> <p class="post-meta"> Created in February 20, 2025 </p> <p class="post-tags"> <a href="/blog/2025"> <i class="fa-solid fa-calendar fa-sm"></i> 2025 </a>   ·   <a href="/blog/tag/math"> <i class="fa-solid fa-hashtag fa-sm"></i> math</a>   ·   <a href="/blog/category/sample-posts"> <i class="fa-solid fa-tag fa-sm"></i> sample-posts</a> </p> </header> <article class="post-content"> <div id="markdown-content"> <p>For some physics simulations on surfaces, it can be useful (for efficiency, simplicity, etc.) to first simulate an object in 2D as a sector before wrapping into 3D. For example, if you are interested in modelling a sector of a cloth draped over a conical surface. The 3D object can be thought of as being generated by rolling the 2D sector around its origin.</p> <p>In these situations, it’s necessary to compute the <a href="https://en.wikipedia.org/wiki/Pushforward_(differential)" rel="external nofollow noopener" target="_blank">pushforward</a> for the 2D vector field to 3D space. This post breaks down the process for doing so, and for <a href="https://en.wikipedia.org/wiki/Pullback_(differential_geometry)" rel="external nofollow noopener" target="_blank">pulling the vectors back</a>, which might be useful for post processing analysis.</p> <p><strong><em>General Remark:</em></strong> <em>While I focus on the example of rolling a 2D sector onto a cone, everything here is actually a special case of mapping from a 2D parameter domain \((r,\phi)\) into a 3D surface \((x(r,\phi),\,y(r,\phi),\,z(r,\phi))\). In more general settings, we have a surface \(S \subset \mathbb{R}^3\) parameterized by \(F(u,v) = (x(u,v), y(u,v), z(u,v))\). The pushforward of a 2D vector \(\langle{v^u, v^v}\rangle{}\) is given by \(v^{u}\frac{\partial F}{\partial u} + v^{v}\frac{\partial F}{\partial v}\). The same approach—deriving the Jacobian \(\frac{\partial(x,y,z)}{\partial(r,\phi)}\) and then using it to push vectors forward—applies to any smooth parametric surface, whether it’s a cylinder, a sphere (in patches), or something more complicated.</em></p> <hr> <p>We start with a velocity vector defined in a local 2D Cartesian plane and need to map it into a 3D Cartesian system. This means we need to transform its positional coordinates \((x,y)\) to \((x,y,z)\) and its component vectors \((v_x, v_y)\) to \((v_x,v_y,v_z)\).</p> <p>However, instead of going directly from \((v_x,v_y)\) to \((v_x,v_y,v_z)\), we will first switch to polar coordinates \((r,\phi)\) and components \((v_r, v_{\phi})\) to take advantage of natural cylindrical symmetry, and then embed into 3D.</p> <h2 id="step-1-from-xy-to-rphi-and-v_xv_y-to-v_r-v_phi">Step 1: From \((x,y)\) to \((r,\phi)\) and \((v_x,v_y)\) to \((v_r, v_{\phi})\)</h2> <p>The vector lives at position \((x,y)\) on the sector. First, let’s get the polar coordinates of the vector’s position (NOT to be confused with the radial and tangential components of the vector).</p> \[\begin{cases} r = \sqrt{x^2 + y^2},\\ \phi = \operatorname{atan2}(y,\,x)., \\ \end{cases}\] <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="c1"># Generate random example x,y coords
</span><span class="n">num_samples</span> <span class="o">=</span> <span class="mi">10</span> 
<span class="n">xy</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">uniform</span><span class="p">(</span><span class="o">-</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="p">(</span><span class="n">num_samples</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> 
<span class="n">x</span> <span class="o">=</span> <span class="n">xy</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">xy</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">sqrt</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span><span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="c1"># or np.linalg.norm(xy)
</span><span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">arctan2</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="c1"># arctan(y,x)
</span></code></pre></div></div> <p>Although we didn’t enforce it here, let’s pretend these \((x,y)\) points are certainly on the sector of interest.</p> <p>Next, to map a vector \((v_x, v_y)\) to its polar form \((v_r, v_{\phi})\), we need to express it in terms of its radial and tangential components. \(\begin{cases} v_r = v_xcos(\phi)+ v_ysin(\phi), \\ v_{\phi} = -v_xsin(\phi) + v_ycos(\phi) \end{cases}\)</p> <p>\(v_r\) tells us how much of the vector is increasing in the direction \(r\), and \(v_{\phi}\) tells us how much of the vector is increasing in the direction perpendicular to \(r\), i.e. tangent to the circular motion.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Random example vector components
</span><span class="n">vxy</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">uniform</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span> <span class="p">(</span><span class="n">num_samples</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> 
<span class="n">vx</span> <span class="o">=</span> <span class="n">vxy</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
<span class="n">vy</span> <span class="o">=</span> <span class="n">vxy</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
<span class="n">v_r</span>  <span class="o">=</span> <span class="n">vx</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="nf">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span> <span class="o">+</span> <span class="n">vy</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="nf">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span>
<span class="n">v_phi</span> <span class="o">=</span> <span class="o">-</span><span class="n">vx</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="nf">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span> <span class="o">+</span> <span class="n">vy</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="nf">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span>
</code></pre></div></div> <p><strong><em>Side Note on Coordinate vs. Orthonormal Vectors:</em></strong> <em>Here, \((v_r, v_{\phi})\) are the <strong>coordinate-basis</strong> components in polar coordinates. In some applications (e.g for certain PDEs on surfaces), you might want an <strong>orthonormal</strong> basis \(\hat{r}, \hat{\phi}\), Then \(\hat{\phi} = (\frac{1}{r})\frac{\partial}{\partial \phi}\), and the formula for \(v_{\phi}\) would involve different factors of \(r\). For this post, we stick to coordinate-basis compnents – just keep in mind if you need unit vectors in the future.</em></p> <p>Now that we’ve got the vector’s original coordinates and components in polar space, we’re ready to embed the vector in 3D space.</p> <h2 id="step-2-from-rphi-to-xyz">Step 2: From \((r,\phi)\) to \((x,y,z)\)</h2> <p>First, note that since we are rolling a periodic sector of a circle into a cone, we need to obtain symmetry factor \(k\), which describes the number of times the cone needs to be wrapped in order to follow the periodicity. \(k\) is \(2\pi\) (the ‘full angle’ in radians) divided by the opening angle of the sector \(\alpha\), so \(k = \frac{2\pi}{\alpha}\). This means if, for example, \(\alpha = \frac{\pi}{2}\), then \(k = 4\), and the intuition behind that is that the sector would be wrapped four times around the cone. Note that the derivation of the Jacobian below is only valid for \(\alpha &lt; 2\pi\).</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">pi</span><span class="o">/</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">uniform</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span> <span class="c1"># let's say alpha is somewhere between pi/4 and pi
</span><span class="n">k</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="n">pi</span><span class="o">/</span><span class="n">alpha</span> 
<span class="n">theta</span> <span class="o">=</span> <span class="n">phi</span> <span class="o">*</span> <span class="n">k</span> <span class="c1"># New angular coordinate on the cone
</span></code></pre></div></div> <p><strong><em>Tip / Boundary Caution:</em></strong> <em>At \(r = 0\) then we are at the cone tip. The Jacobian can degenerate there. Practically, that just means that you have to be careful pushing forward or back at exactly at the tip; the geometry has a singularity. You will see when we introduce an epsilon factor to deal with this later. In other applications, it can be fine to exclude \(r=0\) from the domain or handle it with special boundary conditions depending on the real world analog.</em></p> <p>We need the Jacobian of \((x,y,z)\) with respect to \((r,\phi)\) to see how infinitesimal displacements \((\partial{r}, \partial{\phi})\) in 2D become displacements in \((dx, dy, dz)\). The Jacobian acts as a change-of-basis matrix that allows us to correctly express how vectors in the 2D domain correspond to vectors in 3D. Or in other words, to account for how distances and angles change under the rolling process, which introduces non-linear distortions.</p> \[J = \begin{bmatrix} \frac{\partial x}{\partial r} &amp; \frac{\partial x}{\partial \phi} \\ \frac{\partial y}{\partial r} &amp; \frac{\partial y}{\partial \phi} \\ \frac{\partial z}{\partial r} &amp; \frac{\partial z}{\partial \phi} \end{bmatrix}\] <p>Using the transformation equations:</p> \[\begin{cases} x = \frac{r}{k} \cos(\theta), \\ y = \frac{r}{k} \sin(\theta), \\ z = \frac{r}{k} \sqrt{k^2 - 1}, \\ \theta = k \phi. \end{cases}\] <p>We compute the partial derivatives:</p> <ol> <li> <p><strong>Partial derivatives with respect to \(r\):</strong> \(\frac{\partial x}{\partial r} = \frac{1}{k} \cos(\theta), \quad \frac{\partial y}{\partial r} = \frac{1}{k} \sin(\theta), \quad \frac{\partial z}{\partial r} = \frac{1}{k} \sqrt{k^2 - 1}.\)</p> </li> <li> <p><strong>Partial derivatives with respect to \(\phi\):</strong> \(\frac{\partial x}{\partial \phi} = -\frac{r}{k} \sin(\theta) \cdot k = -r \sin(\theta),\) \(\frac{\partial y}{\partial \phi} = \frac{r}{k} \cos(\theta) \cdot k = r \cos(\theta),\) \(\frac{\partial z}{\partial \phi} = 0.\)</p> </li> </ol> <p>Thus, the <strong>Jacobian matrix</strong> is:</p> \[J = \begin{bmatrix} \frac{\cos(\theta)}{k} &amp; -r \sin(\theta) \\ \frac{\sin(\theta)}{k} &amp; r \cos(\theta) \\ \frac{\sqrt{k^2 - 1}}{k} &amp; 0 \end{bmatrix}\] <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">df_dr</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">stack</span><span class="p">(</span>
    <span class="p">(</span>
        <span class="n">np</span><span class="p">.</span><span class="nf">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">/</span> <span class="n">k</span><span class="p">,</span>
        <span class="n">np</span><span class="p">.</span><span class="nf">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">/</span> <span class="n">k</span><span class="p">,</span>
        <span class="n">np</span><span class="p">.</span><span class="nf">full_like</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="nf">sqrt</span><span class="p">(</span><span class="n">k</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">k</span><span class="p">)</span>
    <span class="p">),</span>
    <span class="n">axis</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
<span class="p">)</span>

<span class="n">df_dphi</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">stack</span><span class="p">(</span>
    <span class="p">(</span>
        <span class="o">-</span><span class="n">r</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="nf">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span>
        <span class="n">np</span><span class="p">.</span><span class="nf">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span>
        <span class="n">np</span><span class="p">.</span><span class="nf">zeros_like</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
    <span class="p">),</span>
    <span class="n">axis</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
<span class="p">)</span>

<span class="n">v_xyz</span> <span class="o">=</span> <span class="n">v_r</span><span class="p">[...,</span> <span class="n">np</span><span class="p">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">*</span> <span class="n">df_dr</span> <span class="o">+</span> <span class="n">v_phi</span><span class="p">[...,</span> <span class="n">np</span><span class="p">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">*</span> <span class="n">df_dphi</span>
</code></pre></div></div> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span> 
<span class="k">def</span> <span class="nf">pushforward</span><span class="p">(</span>
    <span class="n">xy</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">vxy</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">alpha</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">:</span> 
    <span class="n">k</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="n">pi</span><span class="o">/</span><span class="n">alpha</span> 

    <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">sqrt</span><span class="p">(</span><span class="n">xy</span><span class="p">[...,</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span><span class="n">xy</span><span class="p">[...,</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="c1"># or np.linalg.norm(xy)
</span>    <span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">arctan2</span><span class="p">(</span><span class="n">xy</span><span class="p">[...,</span><span class="mi">1</span><span class="p">],</span> <span class="n">xy</span><span class="p">[...,</span><span class="mi">0</span><span class="p">])</span> <span class="c1"># arctan(y,x)
</span>    <span class="n">theta</span> <span class="o">=</span> <span class="n">phi</span> <span class="o">*</span> <span class="n">k</span>  <span class="c1"># New angular coordinate on the cone
</span>    
    <span class="c1"># polar components of vector
</span>    <span class="n">v_r</span>  <span class="o">=</span> <span class="n">vxy</span><span class="p">[...,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="nf">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span> <span class="o">+</span> <span class="n">vxy</span><span class="p">[...,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="nf">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span>
    <span class="n">v_phi</span> <span class="o">=</span> <span class="o">-</span><span class="n">vxy</span><span class="p">[...,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="nf">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span> <span class="o">+</span> <span class="n">vxy</span><span class="p">[...,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="nf">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span>


    <span class="n">df_dr</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">stack</span><span class="p">(</span>
        <span class="p">(</span>
            <span class="n">np</span><span class="p">.</span><span class="nf">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">/</span> <span class="n">k</span><span class="p">,</span>
            <span class="n">np</span><span class="p">.</span><span class="nf">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">/</span> <span class="n">k</span><span class="p">,</span>
            <span class="n">np</span><span class="p">.</span><span class="nf">full_like</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="nf">sqrt</span><span class="p">(</span><span class="n">k</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">k</span><span class="p">)</span>
        <span class="p">),</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="p">)</span>

    <span class="n">df_dphi</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">stack</span><span class="p">(</span>
        <span class="p">(</span>
            <span class="o">-</span><span class="n">r</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="nf">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span>
            <span class="n">np</span><span class="p">.</span><span class="nf">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span>
            <span class="n">np</span><span class="p">.</span><span class="nf">zeros_like</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
        <span class="p">),</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">v_r</span><span class="p">[...,</span> <span class="n">np</span><span class="p">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">*</span> <span class="n">df_dr</span> <span class="o">+</span> <span class="n">v_phi</span><span class="p">[...,</span> <span class="n">np</span><span class="p">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">*</span> <span class="n">df_dphi</span>

</code></pre></div></div> <h2 id="pullback">Pullback</h2> <p>First we must recover \(r\) and \(\phi\) from the cone point. There is a trap here, however, as \(\phi\) cannot be directly recovered due to the ambiguity introduced by \(\theta = \operatorname{atan2}(y,x)\). The function [<a href="https://en.wikipedia.org/wiki/Atan2" rel="external nofollow noopener" target="_blank">\(\operatorname{atan2}\)</a>] returns values in the range \((-\pi, \pi)\), while actual angle \(\theta = k\phi\) is periodic naturally wraps modulo \(2\pi\) on the base of the cone. Because of this, using \(\operatorname{atan2}\) alone would lose information about the true value of \(\phi\), making an accurate pullback impossible.</p> <p><strong><em>Global vs Local:</em></strong> <em>This is a prime example of how parameterization can cause trouble if the image “wraps around.” Locally, you can invert \(\theta \to \phi\), but globally, you might need to keep track of extra offset or stored data about which “turn” the unwrapped sector was on.</em></p> <h4 id="why-the-transpose">Why the Transpose?</h4> <p>When we do the pullback, conceputally we are computing: \((v_r, v_{\phi}) = \langle{v_{xyz}, \frac{partial{F}}{\partial{r}}}\rangle{}, \frac{partial{F}}{\partial{\phi}}\rangle{}.\) From a linear algebra perspective, that is precisely the transpose of the Jacobian matrix. Hence “pullback = transpose of pushforward” (in coordinate-basis form when the coordinate-basis vectors are orthogonal).</p> <p>Before we pullback, we need a function that compute \((x,y,z)\) on the cone. In order to do so, all we need are the original \((x,y)\) coordinates and the opening angle \(\alpha\). We borrow from the math earlier that showed this mapping.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">map_xy_to_xyz</span><span class="p">(</span>
    <span class="n">xy</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">alpha</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="n">k</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="n">pi</span><span class="o">/</span><span class="n">alpha</span> 
    <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">sqrt</span><span class="p">(</span><span class="n">xy</span><span class="p">[...,</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">xy</span><span class="p">[...,</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">arctan2</span><span class="p">(</span><span class="n">xy</span><span class="p">[...,</span><span class="mi">1</span><span class="p">],</span><span class="n">xy</span><span class="p">[...,</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="n">phi</span> <span class="o">*</span> <span class="n">k</span> 
    <span class="c1"># scale down radius by symmetry factor to ensure correct perimeter length 
</span>    <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">r</span><span class="o">/</span><span class="n">k</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="nf">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="n">r</span><span class="o">/</span><span class="n">k</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="nf">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
    <span class="n">z</span> <span class="o">=</span> <span class="p">(</span><span class="n">r</span><span class="o">/</span><span class="n">k</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="nf">sqrt</span><span class="p">(</span><span class="n">k</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="p">.</span><span class="nf">stack</span><span class="p">([</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
</code></pre></div></div> <p>Great, now we can assume we have the x,y,z coordinates on the cone. We are ready for the pullback.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">pullback</span><span class="p">(</span>
    <span class="n">xyz</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">v_xyz</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">original_phi</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">alpha</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">:</span> 

    <span class="n">k</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="n">pi</span> <span class="o">/</span> <span class="n">alpha</span> 
    <span class="n">theta</span> <span class="o">=</span> <span class="n">original_phi</span> <span class="o">*</span> <span class="n">k</span> 

    <span class="c1"># Recover r from the cone coordinates
</span>    <span class="n">cone_x</span> <span class="o">=</span> <span class="n">xyz</span><span class="p">[...,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">cone_y</span> <span class="o">=</span> <span class="n">xyz</span><span class="p">[...,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">k</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="nf">sqrt</span><span class="p">(</span><span class="n">cone_x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">cone_y</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>


    <span class="n">df_dr_t</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">stack</span><span class="p">(</span>
        <span class="p">[</span>
            <span class="n">np</span><span class="p">.</span><span class="nf">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span><span class="o">/</span><span class="n">k</span><span class="p">,</span>
            <span class="n">np</span><span class="p">.</span><span class="nf">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span><span class="o">/</span><span class="n">k</span><span class="p">,</span>
            <span class="n">np</span><span class="p">.</span><span class="nf">full_like</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="nf">sqrt</span><span class="p">(</span><span class="n">k</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">k</span><span class="p">),</span>
        <span class="p">],</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">df_dphi_t</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">stack</span><span class="p">(</span>
        <span class="p">[</span>
            <span class="o">-</span><span class="n">r</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="nf">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span>
            <span class="n">r</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="nf">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span>
            <span class="n">np</span><span class="p">.</span><span class="nf">zeros_like</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
        <span class="p">],</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="p">)</span>

    <span class="c1"># Recover the polar components of the 2d vector
</span>    <span class="n">epsilon</span> <span class="o">=</span> <span class="mf">1e-8</span> <span class="c1"># include epsilon to avoid divide by 0 at (x = 0, y = 0)
</span>    <span class="n">v_r</span> <span class="o">=</span> <span class="p">(</span><span class="n">v_xyz</span> <span class="o">*</span> <span class="n">df_dr_t</span><span class="p">).</span><span class="nf">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">v_phi</span> <span class="o">=</span> <span class="p">(</span><span class="n">v_xyz</span> <span class="o">*</span> <span class="n">df_dphi_t</span><span class="p">).</span><span class="nf">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">r</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">epsilon</span><span class="p">)</span> 

    <span class="c1"># Convert polar components back to Cartesian 
</span>    <span class="n">v_x</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">cos</span><span class="p">(</span><span class="n">original_phi</span><span class="p">)</span> <span class="o">*</span> <span class="n">v_r</span> <span class="o">-</span> <span class="n">np</span><span class="p">.</span><span class="nf">sin</span><span class="p">(</span><span class="n">original_phi</span><span class="p">)</span> <span class="o">*</span> <span class="n">v_phi</span>
    <span class="n">v_y</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">sin</span><span class="p">(</span><span class="n">original_phi</span><span class="p">)</span> <span class="o">*</span> <span class="n">v_r</span> <span class="o">+</span> <span class="n">np</span><span class="p">.</span><span class="nf">cos</span><span class="p">(</span><span class="n">original_phi</span><span class="p">)</span> <span class="o">*</span> <span class="n">v_phi</span>

    <span class="k">return</span> <span class="n">np</span><span class="p">.</span><span class="nf">stack</span><span class="p">([</span><span class="n">v_x</span><span class="p">,</span> <span class="n">v_y</span><span class="p">],</span> <span class="n">axis</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> 

</code></pre></div></div> <hr> <p><strong><em>Coordinate vs. Orthonormal Again:</em></strong> <em>Depending on how you define \((v_r, v_{\phi})\), you might do “divide by \(r\)” in that last step (rather than \(r^2\)). Our choice is consistent with using the raw coordinate basis for polar coordinates – namely, \(\frac{\partial}{\partial{r}}\) and \(\frac{\partial}{\partial{\phi}}\). In that coordinate basis, the vector \(\frac{\partial}{\partial{\phi}}\) has length \(r\). Consequently, if a vector \(v\) in the plane is written as \(v = v_r\frac{\partial}{\partial{r}} + v_{\phi}\frac{\partial}{\partial{\phi}}\), then \(v_{\phi}\) is the coefficient of a basis vector whose norm is \(r\).</em></p> <p><em>If, instead, you prefer an orthonormal basis \({\hat{r}, \hat{\phi}}\), you would define \(\hat{r} = \frac{\partial}{\partial{r}} / \left\|\frac{\partial}{\partial{r}}\right\|\), \(\hat{\phi} = \frac{\partial}{\partial{\phi}} / \left\|\frac{\partial}{\partial{\phi}}\right\|\). And in standard polar coordinates \(\left\|\frac{\partial}{\partial{\phi}}\right\| = r\). That means \(\hat{\phi} = (\frac{1}{r})\frac{\partial}{\partial{\phi}}.\)</em></p> <p><em>So an orthonormal decomposition would look like \(v = (v_r^{(orth.)})\hat{r} + (v_{\phi}^{(orth.)})\hat{\phi}\), which translates back to the coordinate basis via:</em></p> \[v = v_r^{(orth.)}\frac{\partial}{\partial{r}} + v_{\phi}^{(orth.)}(r\hat{\phi}) = v_r^{(orth.)}\frac{\partial}{\partial{r}} + (rv_{\phi}^{(orth.)})\frac{\partial}{\partial{\phi}}\] <p><em>Hence, if you had originally stored \((v_r^{(orth.)}, v_{\phi}^{(orth.)})\) in an orthonormal basis, you would need an extra factor of \(r\) somewhere when converting to (or from) the raw coordinate basis. In short, the difference in dividing by \(r^2\) vs. \(r\) vs. no factor is all about which basis you are using for your 2D vectors:</em> \</p> <ul> <li> <strong>Raw coordinate basis:</strong> \((\frac{\partial}{\partial{r}}, \frac{\partial}{\partial{\phi}})\).</li> <li> <strong>Orthonormal basis:</strong> \({\hat{r}, \hat{\phi}}\), with \(\hat{\phi} = \frac{1}{r}\frac{\partial}{\partial{\phi}}\).</li> </ul> <p><em>Our cone example and its code stick to the simpler coordinate basis convention, which is why you see (\(v_{\phi}\))-related operations divided by \(r^2\) or \(r\) in a few places. If you switch to an orthonormal basis, you’ll need to adjust those factors accordingly.</em></p> <hr> <h2 id="putting-it-all-together">Putting it all together</h2> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">num_samples</span> <span class="o">=</span> <span class="mi">10</span> 
<span class="n">xy</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">uniform</span><span class="p">(</span><span class="o">-</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="p">(</span><span class="n">num_samples</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> 
<span class="n">vxy</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">uniform</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span> <span class="p">(</span><span class="n">num_samples</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> 
<span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">pi</span><span class="o">/</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">uniform</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span> <span class="c1"># let's say alpha is somewhere between pi/4 and pi
</span>
<span class="c1"># Push forward
</span><span class="n">v_xyz</span> <span class="o">=</span> <span class="nf">pushforward</span><span class="p">(</span><span class="n">xy</span><span class="p">,</span> <span class="n">vxy</span><span class="p">,</span> <span class="n">alpha</span><span class="p">)</span>
<span class="c1">#W
# Remember we need to store the original phi
</span><span class="n">original_phi</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">arctan2</span><span class="p">(</span><span class="n">xy</span><span class="p">[...,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">xy</span><span class="p">[...,</span> <span class="mi">0</span><span class="p">])</span>

<span class="n">xyz</span> <span class="o">=</span> <span class="nf">map_xy_to_xyz</span><span class="p">(</span><span class="n">xy</span><span class="p">,</span> <span class="n">alpha</span><span class="p">)</span>

<span class="c1"># Pull back
</span><span class="n">vxy</span> <span class="o">=</span> <span class="nf">pullback</span><span class="p">(</span>
    <span class="n">xyz</span><span class="p">,</span> 
    <span class="n">v_xyz</span><span class="p">,</span> 
    <span class="n">original_phi</span><span class="p">,</span> 
    <span class="n">alpha</span>
<span class="p">)</span>
</code></pre></div></div> <h2 id="geometric-intuition">Geometric Intuition</h2> <ul> <li>Going via \((r,\theta)\) is useful if the 3D surface naturally uses polar-like coordinates (e.g., cones, cylinders, paraboloids).</li> <li>The Jacobian \(\frac{\partial (x,y,z)}{\partial (r,\theta)}\) encodes how motions in \((r,\theta)\) “push forward” into 3D space.</li> <li> <strong>Rolling/unrolling:</strong> The factor \(k = \frac{2\pi}{\alpha}\) ensures that when you go around the cone once, you go around \(2\pi\) in \(\theta\). This matches the sector’s arc length \(\alpha \times r\).</li> <li> <strong>Tip singularities:</strong> At \(r = 0\), the cone’s apex. Watch for degenerate Jacobians.</li> </ul> <p><strong><em>Beyond Cones:</em></strong> <em>This same approach generalizes to any surface parameterization \((u,v) \to (x(u,v), y(u,v), z(u,v))\). If your surface is a simple patch (like a rectangle), you can still compute partial derivatives w.r.t. \((u,v)\) and push forward vectors or pull them back. The only difference is how you define \((x(u,v), y(u,v), z(u,v))\).</em></p> <h1 id="plots">Plots</h1> <p>Pending… (this stuff can lead to some nice plots…)</p> </div> </article> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2025 Chris Hull. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js?a0db7e5d5c70cc3252b3138b0c91dcaf" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script src="/assets/js/mathjax-setup.js?70d799092f862ad98c7876aa47712e20"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script defer src="/assets/js/progress-bar.js?2f30e0e6801ea8f5036fa66e1ab0a71a" type="text/javascript"></script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>
    addBackToTop();
  </script> <script type="module" src="/assets/js/search/ninja-keys.min.js?a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script src="/assets/js/search-setup.js?6c304f7b1992d4b60f7a07956e52f04a"></script> <script src="/assets/js/search-data.js"></script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> <script defer src="/assets/js/newsletter.js?c3d0931971ee96e9df74ba70526c3130"></script> </body> </html>